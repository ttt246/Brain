package com.matthaigh27.chatgptwrapper.utils

import android.annotation.SuppressLint
import android.content.ContentResolver
import android.content.ContentUris
import android.content.Context
import android.database.Cursor
import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.net.Uri
import android.os.Environment
import android.provider.ContactsContract
import android.provider.MediaStore
import android.widget.ImageView
import androidx.room.RoomDatabase
import com.bumptech.glide.Glide
import com.matthaigh27.chatgptwrapper.MyApplication
import com.matthaigh27.chatgptwrapper.R
import com.matthaigh27.chatgptwrapper.database.MyDatabase
import com.matthaigh27.chatgptwrapper.database.entity.ContactEntity
import com.matthaigh27.chatgptwrapper.models.common.ContactModel
import com.matthaigh27.chatgptwrapper.models.common.HelpCommandModel
import com.matthaigh27.chatgptwrapper.models.common.HelpPromptModel
import com.matthaigh27.chatgptwrapper.services.api.HttpClient
import com.matthaigh27.chatgptwrapper.utils.Constants.*
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.async
import kotlinx.coroutines.launch
import org.json.JSONArray
import org.json.JSONException
import org.json.JSONObject
import java.io.ByteArrayOutputStream
import java.io.File
import java.io.FileInputStream
import java.io.FileNotFoundException
import java.io.IOException
import java.io.InputStream
import java.net.HttpURLConnection
import java.net.URL
import java.text.SimpleDateFormat
import java.util.Date
import java.util.Locale

class Utils {
    /**
     * set bitmap from download url generated by firebase store
     *
     * @param src download url of image
     * @return bitmap of the image
     */
    fun getBitmapFromURL(src: String?): Bitmap? {
        return try {
            val url = URL(src)
            val connection: HttpURLConnection = url.openConnection() as HttpURLConnection
            connection.doInput = true
            connection.connect()
            val input: InputStream = connection.inputStream
            BitmapFactory.decodeStream(input)
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    /**
     * @param uri uri for converting to ByteArray
     * @return ByteArray data converted from image uri
     */
    fun convertImageToByte(uri: Uri?): ByteArray? {
        var data: ByteArray? = null
        try {
            val cr = MyApplication.appContext.contentResolver
            val inputStream: InputStream? = cr.openInputStream(uri!!)
            val bitmap = BitmapFactory.decodeStream(inputStream)
            val baos = ByteArrayOutputStream()
            bitmap.compress(Bitmap.CompressFormat.JPEG, 100, baos)
            data = baos.toByteArray()
        } catch (e: FileNotFoundException) {
            e.printStackTrace()
        }
        return data
    }

    /**
     * @param path local path for converting to ByteArray
     * @return ByteArray data converted from image local path
     */
    @Suppress("UNREACHABLE_CODE")
    fun getBytesFromPath(path: String?): ByteArray {
        var byteArray: ByteArray? = null
        try {
            val stream = FileInputStream(path)
            byteArray = stream.readBytes()
            stream.close()
            return byteArray
        } catch (e: IOException) {
            throw Exception(e)
        }
        return byteArray
    }

    /**
     * this creats image file with current datetime captured by camera
     */
    fun createSDCardFile(): File {
        val timeStamp: String =
            SimpleDateFormat("yyyyMMdd_HHmmss", Locale.getDefault()).format(Date())
        val imageFileName = "IMG_" + timeStamp + "_"
        val storageDir: File =
            MyApplication.appContext.getExternalFilesDir(Environment.DIRECTORY_PICTURES)!!
        return File.createTempFile(
            imageFileName,  /* prefix */
            ".jpg",         /* suffix */
            storageDir      /* directory */
        )
    }

    /**
     * when users input command starting with '/'
     *
     * @param strCommand is string with '/' and '-', ex: /browser -d
     * @return command model with main ommand and assistance command
     */
    fun getHelpCommandFromStr(strCommand: String): HelpCommandModel {
        val commandModel = HelpCommandModel()
        if (strCommand == "/$HELP_COMMAND") {
            commandModel.mainCommandName = HELP_COMMAND
            commandModel.assistCommandName = HELP_COMMAND_ALL
            return commandModel
        }
        try {
            if (strCommand.startsWith("/$HELP_COMMAND") || strCommand.startsWith("!$HELP_COMMAND")) {
                val words = strCommand.split("\\s".toRegex()).toTypedArray()
                if (words.size != 2) {
                    throw Exception(HELP_COMMAND_ERROR_NO_MAIN)
                }
                commandModel.mainCommandName = words[0].substring(1, words[0].length)
                commandModel.assistCommandName = words[1]
                if (commandModel.mainCommandName == "" || commandModel.assistCommandName == "") {
                    throw Exception(HELP_COMMAND_ERROR_NO_MAIN)
                }
            } else {
                commandModel.mainCommandName = strCommand.substring(1, strCommand.length)
            }
        } catch (e: Exception) {
            throw Exception(HELP_COMMAND_ERROR_NO_INVALID_FORMAT)
        }
        return commandModel
    }

    fun getHelpCommandListFromJsonString(jsonStrCommandList: String): ArrayList<HelpPromptModel> {
        val commandlist = ArrayList<HelpPromptModel>()
        try {
            val helpCommandStrList = JSONArray(jsonStrCommandList)
            for (i in 0 until helpCommandStrList.length()) {
                val helpCommand = JSONObject(helpCommandStrList[i].toString())

                val helpPromptModel = HelpPromptModel()
                helpPromptModel.name = helpCommand.getString("name")
                helpPromptModel.description = helpCommand.getString("description")
                helpPromptModel.prompt = helpCommand.getString("prompt")

                helpPromptModel.tags = ArrayList()
                val jsonArrayTags = helpCommand.getJSONArray("tags")
                for (j in 0 until jsonArrayTags.length()) {
                    helpPromptModel.tags!!.add(jsonArrayTags[j].toString())
                }
                commandlist.add(helpPromptModel)
            }
        } catch (e: JSONException) {
            e.printStackTrace()
            throw Exception(ERROR_MSG_JSON)
        }
        return commandlist
    }

    @SuppressLint("Range")
    fun getContacts(context: Context): ArrayList<ContactModel> {
        val resolver: ContentResolver = context.contentResolver;
        val cursor = resolver.query(
            ContactsContract.Contacts.CONTENT_URI, null, null, null, null
        )

        val contacts = ArrayList<ContactModel>()
        if (cursor!!.count > 0) {
            while (cursor.moveToNext()) {
                val id = cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts._ID))

                val name =
                    cursor.getString(cursor.getColumnIndex(ContactsContract.Contacts.DISPLAY_NAME))
                val phoneNumber = (cursor.getString(
                    cursor.getColumnIndex(ContactsContract.Contacts.HAS_PHONE_NUMBER)
                )).toInt()

                val contact = ContactModel()
                contact.id = id
                contact.name = name

                if (phoneNumber > 0) {
                    val cursorPhone = context.contentResolver.query(
                        ContactsContract.CommonDataKinds.Phone.CONTENT_URI,
                        null,
                        ContactsContract.CommonDataKinds.Phone.CONTACT_ID + "=?",
                        arrayOf(id),
                        null
                    )

                    if (cursorPhone!!.count > 0) {
                        while (cursorPhone.moveToNext()) {
                            val phoneNumValue = cursorPhone.getString(
                                cursorPhone.getColumnIndex(ContactsContract.CommonDataKinds.Phone.NUMBER)
                            )
                            contact.phoneList!!.add(phoneNumValue)
                        }
                    }
                    cursorPhone.close()
                }

                contacts.add(contact)
            }
        }
        cursor.close()
        return contacts
    }

    suspend fun getChangedContacts(
        contacts: ArrayList<ContactModel>,
        roomDatabaseHandler: MyDatabase
    ): ArrayList<ContactModel> {
        return CoroutineScope(Dispatchers.IO).async {
            val originalContacts = roomDatabaseHandler.contactDao().getAllContacts()
            val changedContactList = ArrayList<ContactModel>()
            for (i in originalContacts.indices) {
                var isExist = false
                contacts.forEach { contact ->
                    if (originalContacts[i].id == contact.id) {
                        if (originalContacts[i].name != contact.name ||
                            originalContacts[i].phoneNumber != contact.phoneList.toString()
                        ) {
                            contact.status = "updated"
                            changedContactList.add(contact)

                            try {
                                roomDatabaseHandler.contactDao().updateContact(
                                    ContactEntity(
                                        contact.id,
                                        contact.name,
                                        contact.phoneList.toString()
                                    )
                                )
                            } catch (e: Exception) {
                                e.printStackTrace()
                            }
                        } else {
                            contact.status = "nothing"
                        }
                        isExist = true
                        return@forEach
                    }
                }
                if (!isExist) {
                    val deletedContacts = ContactModel()
                    deletedContacts.id = originalContacts[i].id
                    deletedContacts.status = "deleted"
                    changedContactList.add(deletedContacts)

                    try {
                        roomDatabaseHandler.contactDao().deleteContact(
                            ContactEntity(
                                deletedContacts.id,
                                deletedContacts.name,
                                deletedContacts.phoneList.toString()
                            )
                        )
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
            contacts.forEach { contact ->
                if (contact.status.isEmpty()) {
                    contact.status = "created"
                    changedContactList.add(contact)
                    try {
                        roomDatabaseHandler.contactDao().insertContact(
                            ContactEntity(
                                contact.id,
                                contact.name,
                                contact.phoneList.toString()
                            )
                        )
                    } catch (e: Exception) {
                        e.printStackTrace()
                    }
                }
            }
            changedContactList
        }.await()
    }

    fun getContactModelById(contactId: String, contacts: ArrayList<ContactModel>): ContactModel {
        var contactModel = ContactModel()
        contacts.forEach { contact ->
            if (contactId == contact.id) {
                return contact
            }
        }
        return contactModel
    }

    fun setContactAvatar(contactId: Long, context: Context, imageView: ImageView) {
        val uri = ContentUris.withAppendedId(
            ContactsContract.Contacts.CONTENT_URI, contactId
        )

        Glide.with(context)
            .load(uri)
            .placeholder(R.drawable.default_avatar) // Set placeholder image
            .error(R.drawable.default_avatar) // Set error image
            .fallback(R.drawable.default_avatar) // Set fallback image
            .into(imageView)
    }

    fun convertContactModelToJsonArray(contacts: ArrayList<ContactModel>): JSONArray {
        var jsonContacts = JSONArray()
        contacts.forEach { contact ->
            val jsonObjectContact = JSONObject()
            jsonObjectContact.put("contactId", contact.id)
            jsonObjectContact.put("displayName", contact.name)
            jsonObjectContact.put("phoneNumbers", contact.phoneList)
            jsonObjectContact.put("status", contact.status)

            jsonContacts.put(jsonObjectContact)
        }
        return jsonContacts
    }

    fun getRealPathFromUri(context: Context, contentUri: Uri?): String? {
        var cursor: Cursor? = null
        return try {
            val proj = arrayOf(MediaStore.Images.Media.DATA)
            cursor = context.contentResolver.query(contentUri!!, proj, null, null, null)
            val column_index: Int = cursor!!.getColumnIndexOrThrow(MediaStore.Images.Media.DATA)
            cursor.moveToFirst()
            cursor.getString(column_index)
        } finally {
            cursor?.close()
        }
    }


    companion object {
        var instance: Utils = Utils()
    }
}